package typeconv

//go:generate ./slice.sh String Int Int64 Int32 Int16 Int8 Uint Uint64 Uint32 Uint16 Uint8

// Code generated by ./slice.sh DO NOT EDIT

// AsStringSlice tries to convert data into a slice of string
func AsStringSlice(v interface{}) ([]string, bool) {
	switch w := v.(type) {
	case []string:
		// ready
		return w, true
	case []interface{}:
		// slice of something else, convert them to String
		out := make([]string, 0, len(w))
		for _, o := range w {
			if n, ok := AsString(o); ok {
				out = append(out, n)
			} else {
				// failed
				return nil, false
			}
		}
		return out, true
	case interface{}:
		// promote single element to slice
		if n, ok := AsString(v); ok {
			return []string{n}, true
		}
	}

	return nil, false
}

// AsIntSlice tries to convert data into a slice of int
func AsIntSlice(v interface{}) ([]int, bool) {
	switch w := v.(type) {
	case []int:
		// ready
		return w, true
	case []interface{}:
		// slice of something else, convert them to Int
		out := make([]int, 0, len(w))
		for _, o := range w {
			if n, ok := AsInt(o); ok {
				out = append(out, n)
			} else {
				// failed
				return nil, false
			}
		}
		return out, true
	case interface{}:
		// promote single element to slice
		if n, ok := AsInt(v); ok {
			return []int{n}, true
		}
	}

	return nil, false
}

// AsInt64Slice tries to convert data into a slice of int64
func AsInt64Slice(v interface{}) ([]int64, bool) {
	switch w := v.(type) {
	case []int64:
		// ready
		return w, true
	case []interface{}:
		// slice of something else, convert them to Int64
		out := make([]int64, 0, len(w))
		for _, o := range w {
			if n, ok := AsInt64(o); ok {
				out = append(out, n)
			} else {
				// failed
				return nil, false
			}
		}
		return out, true
	case interface{}:
		// promote single element to slice
		if n, ok := AsInt64(v); ok {
			return []int64{n}, true
		}
	}

	return nil, false
}

// AsInt32Slice tries to convert data into a slice of int32
func AsInt32Slice(v interface{}) ([]int32, bool) {
	switch w := v.(type) {
	case []int32:
		// ready
		return w, true
	case []interface{}:
		// slice of something else, convert them to Int32
		out := make([]int32, 0, len(w))
		for _, o := range w {
			if n, ok := AsInt32(o); ok {
				out = append(out, n)
			} else {
				// failed
				return nil, false
			}
		}
		return out, true
	case interface{}:
		// promote single element to slice
		if n, ok := AsInt32(v); ok {
			return []int32{n}, true
		}
	}

	return nil, false
}

// AsInt16Slice tries to convert data into a slice of int16
func AsInt16Slice(v interface{}) ([]int16, bool) {
	switch w := v.(type) {
	case []int16:
		// ready
		return w, true
	case []interface{}:
		// slice of something else, convert them to Int16
		out := make([]int16, 0, len(w))
		for _, o := range w {
			if n, ok := AsInt16(o); ok {
				out = append(out, n)
			} else {
				// failed
				return nil, false
			}
		}
		return out, true
	case interface{}:
		// promote single element to slice
		if n, ok := AsInt16(v); ok {
			return []int16{n}, true
		}
	}

	return nil, false
}

// AsInt8Slice tries to convert data into a slice of int8
func AsInt8Slice(v interface{}) ([]int8, bool) {
	switch w := v.(type) {
	case []int8:
		// ready
		return w, true
	case []interface{}:
		// slice of something else, convert them to Int8
		out := make([]int8, 0, len(w))
		for _, o := range w {
			if n, ok := AsInt8(o); ok {
				out = append(out, n)
			} else {
				// failed
				return nil, false
			}
		}
		return out, true
	case interface{}:
		// promote single element to slice
		if n, ok := AsInt8(v); ok {
			return []int8{n}, true
		}
	}

	return nil, false
}

// AsUintSlice tries to convert data into a slice of uint
func AsUintSlice(v interface{}) ([]uint, bool) {
	switch w := v.(type) {
	case []uint:
		// ready
		return w, true
	case []interface{}:
		// slice of something else, convert them to Uint
		out := make([]uint, 0, len(w))
		for _, o := range w {
			if n, ok := AsUint(o); ok {
				out = append(out, n)
			} else {
				// failed
				return nil, false
			}
		}
		return out, true
	case interface{}:
		// promote single element to slice
		if n, ok := AsUint(v); ok {
			return []uint{n}, true
		}
	}

	return nil, false
}

// AsUint64Slice tries to convert data into a slice of uint64
func AsUint64Slice(v interface{}) ([]uint64, bool) {
	switch w := v.(type) {
	case []uint64:
		// ready
		return w, true
	case []interface{}:
		// slice of something else, convert them to Uint64
		out := make([]uint64, 0, len(w))
		for _, o := range w {
			if n, ok := AsUint64(o); ok {
				out = append(out, n)
			} else {
				// failed
				return nil, false
			}
		}
		return out, true
	case interface{}:
		// promote single element to slice
		if n, ok := AsUint64(v); ok {
			return []uint64{n}, true
		}
	}

	return nil, false
}

// AsUint32Slice tries to convert data into a slice of uint32
func AsUint32Slice(v interface{}) ([]uint32, bool) {
	switch w := v.(type) {
	case []uint32:
		// ready
		return w, true
	case []interface{}:
		// slice of something else, convert them to Uint32
		out := make([]uint32, 0, len(w))
		for _, o := range w {
			if n, ok := AsUint32(o); ok {
				out = append(out, n)
			} else {
				// failed
				return nil, false
			}
		}
		return out, true
	case interface{}:
		// promote single element to slice
		if n, ok := AsUint32(v); ok {
			return []uint32{n}, true
		}
	}

	return nil, false
}

// AsUint16Slice tries to convert data into a slice of uint16
func AsUint16Slice(v interface{}) ([]uint16, bool) {
	switch w := v.(type) {
	case []uint16:
		// ready
		return w, true
	case []interface{}:
		// slice of something else, convert them to Uint16
		out := make([]uint16, 0, len(w))
		for _, o := range w {
			if n, ok := AsUint16(o); ok {
				out = append(out, n)
			} else {
				// failed
				return nil, false
			}
		}
		return out, true
	case interface{}:
		// promote single element to slice
		if n, ok := AsUint16(v); ok {
			return []uint16{n}, true
		}
	}

	return nil, false
}

// AsUint8Slice tries to convert data into a slice of uint8
func AsUint8Slice(v interface{}) ([]uint8, bool) {
	switch w := v.(type) {
	case []uint8:
		// ready
		return w, true
	case []interface{}:
		// slice of something else, convert them to Uint8
		out := make([]uint8, 0, len(w))
		for _, o := range w {
			if n, ok := AsUint8(o); ok {
				out = append(out, n)
			} else {
				// failed
				return nil, false
			}
		}
		return out, true
	case interface{}:
		// promote single element to slice
		if n, ok := AsUint8(v); ok {
			return []uint8{n}, true
		}
	}

	return nil, false
}
