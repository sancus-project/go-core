package typeconv

//go:generate ./intsize.sh

import (
	"strconv"
)

// Code generated by ./intsize.sh DO NOT EDIT

// AsIntN tries to convert data into an int of given size
func AsIntN(v interface{}, bitsize int) (int64, error) {
	var n int64
	var err error

	switch w := v.(type) {
	case string:
		n, err = strconv.ParseInt(w, 10, bitsize)
	case int:
		n, err = asIntN(int64(w), IntSize, bitsize)
	case int64:
		n, err = asIntN(w, 64, bitsize)
	case int32:
		n, err = asIntN(int64(w), 32, bitsize)
	case int16:
		n, err = asIntN(int64(w), 16, bitsize)
	case int8:
		n, err = asIntN(int64(w), 8, bitsize)
	case uint:
		n, err = asIntN2(uint64(w), IntSize, 64)
	case uint64:
		n, err = asIntN2(uint64(w), 64, 64)
	case uint32:
		n, err = asIntN2(uint64(w), 32, 64)
	case uint16:
		n, err = asIntN2(uint64(w), 16, 64)
	case uint8:
		n, err = asIntN2(uint64(w), 8, 64)
	default:
		err = InvalidTypeError(v)
	}

	return int64(n), err
}

// AsInt64 tries to convert data into an int64
func AsInt64(v interface{}) (int64, error) {
	var n int64
	var err error

	switch w := v.(type) {
	case string:
		n, err = strconv.ParseInt(w, 10, 64)
	case int64:
		return w, nil
	case int32:
		return int64(w), nil
	case int16:
		return int64(w), nil
	case int8:
		return int64(w), nil
	case int:
		return int64(w), nil
	case uint64:
		n, err = asIntN2(uint64(w), 64, 64)
	case uint32:
		n, err = asIntN2(uint64(w), 32, 64)
	case uint16:
		n, err = asIntN2(uint64(w), 16, 64)
	case uint8:
		n, err = asIntN2(uint64(w), 8, 64)
	case uint:
		n, err = asIntN2(uint64(w), IntSize, 64)
	default:
		err = InvalidTypeError(v)
	}

	return int64(n), err
}

// AsInt32 tries to convert data into an int32
func AsInt32(v interface{}) (int32, error) {
	var n int64
	var err error

	switch w := v.(type) {
	case string:
		n, err = strconv.ParseInt(w, 10, 32)
	case int32:
		return w, nil
	case int16:
		return int32(w), nil
	case int8:
		return int32(w), nil
	case int:
		n, err = asIntN(int64(w), IntSize, 32)
	case int64:
		n, err = asIntN(int64(w), 64, 32)
	case uint32:
		n, err = asIntN2(uint64(w), 32, 32)
	case uint:
		n, err = asIntN2(uint64(w), IntSize, 32)
	case uint64:
		n, err = asIntN2(uint64(w), 64, 32)
	case uint16:
		n, err = asIntN2(uint64(w), 16, 32)
	case uint8:
		n, err = asIntN2(uint64(w), 8, 32)
	default:
		err = InvalidTypeError(v)
	}

	return int32(n), err
}

// AsInt16 tries to convert data into an int16
func AsInt16(v interface{}) (int16, error) {
	var n int64
	var err error

	switch w := v.(type) {
	case string:
		n, err = strconv.ParseInt(w, 10, 16)
	case int16:
		return w, nil
	case int8:
		return int16(w), nil
	case int:
		n, err = asIntN(int64(w), IntSize, 16)
	case int64:
		n, err = asIntN(int64(w), 64, 16)
	case int32:
		n, err = asIntN(int64(w), 32, 16)
	case uint16:
		n, err = asIntN2(uint64(w), 16, 16)
	case uint:
		n, err = asIntN2(uint64(w), IntSize, 16)
	case uint64:
		n, err = asIntN2(uint64(w), 64, 16)
	case uint32:
		n, err = asIntN2(uint64(w), 32, 16)
	case uint8:
		n, err = asIntN2(uint64(w), 8, 16)
	default:
		err = InvalidTypeError(v)
	}

	return int16(n), err
}

// AsInt8 tries to convert data into an int8
func AsInt8(v interface{}) (int8, error) {
	var n int64
	var err error

	switch w := v.(type) {
	case string:
		n, err = strconv.ParseInt(w, 10, 8)
	case int8:
		return w, nil
	case int:
		n, err = asIntN(int64(w), IntSize, 8)
	case int64:
		n, err = asIntN(int64(w), 64, 8)
	case int32:
		n, err = asIntN(int64(w), 32, 8)
	case int16:
		n, err = asIntN(int64(w), 16, 8)
	case uint8:
		n, err = asIntN2(uint64(w), 8, 8)
	case uint:
		n, err = asIntN2(uint64(w), IntSize, 8)
	case uint64:
		n, err = asIntN2(uint64(w), 64, 8)
	case uint32:
		n, err = asIntN2(uint64(w), 32, 8)
	case uint16:
		n, err = asIntN2(uint64(w), 16, 8)
	default:
		err = InvalidTypeError(v)
	}

	return int8(n), err
}

// AsUintN tries to convert data into a uint of given size
func AsUintN(v interface{}, bitsize int) (uint64, error) {
	var n uint64
	var err error

	switch w := v.(type) {
	case string:
		n, err = strconv.ParseUint(w, 10, bitsize)
	case uint:
		n, err = asUintN(uint64(w), IntSize, bitsize)
	case uint64:
		n, err = asUintN(w, 64, bitsize)
	case uint32:
		n, err = asUintN(uint64(w), 32, bitsize)
	case uint16:
		n, err = asUintN(uint64(w), 16, bitsize)
	case uint8:
		n, err = asUintN(uint64(w), 8, bitsize)
	case int:
		n, err = asUintN2(int64(w), IntSize, 64)
	case int64:
		n, err = asUintN2(int64(w), 64, 64)
	case int32:
		n, err = asUintN2(int64(w), 32, 64)
	case int16:
		n, err = asUintN2(int64(w), 16, 64)
	case int8:
		n, err = asUintN2(int64(w), 8, 64)
	default:
		err = InvalidTypeError(v)
	}

	return uint64(n), err
}

// AsUint64 tries to convert data into a uint64
func AsUint64(v interface{}) (uint64, error) {
	var n uint64
	var err error

	switch w := v.(type) {
	case string:
		n, err = strconv.ParseUint(w, 10, 64)
	case uint64:
		return w, nil
	case uint32:
		return uint64(w), nil
	case uint16:
		return uint64(w), nil
	case uint8:
		return uint64(w), nil
	case uint:
		return uint64(w), nil
	case int64:
		n, err = asUintN2(int64(w), 64, 64)
	case int32:
		n, err = asUintN2(int64(w), 32, 64)
	case int16:
		n, err = asUintN2(int64(w), 16, 64)
	case int8:
		n, err = asUintN2(int64(w), 8, 64)
	case int:
		n, err = asUintN2(int64(w), IntSize, 64)
	default:
		err = InvalidTypeError(v)
	}

	return uint64(n), err
}

// AsUint32 tries to convert data into a uint32
func AsUint32(v interface{}) (uint32, error) {
	var n uint64
	var err error

	switch w := v.(type) {
	case string:
		n, err = strconv.ParseUint(w, 10, 32)
	case uint32:
		return w, nil
	case uint16:
		return uint32(w), nil
	case uint8:
		return uint32(w), nil
	case uint:
		n, err = asUintN(uint64(w), IntSize, 32)
	case uint64:
		n, err = asUintN(uint64(w), 64, 32)
	case int32:
		n, err = asUintN2(int64(w), 32, 32)
	case int:
		n, err = asUintN2(int64(w), IntSize, 32)
	case int64:
		n, err = asUintN2(int64(w), 64, 32)
	case int16:
		n, err = asUintN2(int64(w), 16, 32)
	case int8:
		n, err = asUintN2(int64(w), 8, 32)
	default:
		err = InvalidTypeError(v)
	}

	return uint32(n), err
}

// AsUint16 tries to convert data into a uint16
func AsUint16(v interface{}) (uint16, error) {
	var n uint64
	var err error

	switch w := v.(type) {
	case string:
		n, err = strconv.ParseUint(w, 10, 16)
	case uint16:
		return w, nil
	case uint8:
		return uint16(w), nil
	case uint:
		n, err = asUintN(uint64(w), IntSize, 16)
	case uint64:
		n, err = asUintN(uint64(w), 64, 16)
	case uint32:
		n, err = asUintN(uint64(w), 32, 16)
	case int16:
		n, err = asUintN2(int64(w), 16, 16)
	case int:
		n, err = asUintN2(int64(w), IntSize, 16)
	case int64:
		n, err = asUintN2(int64(w), 64, 16)
	case int32:
		n, err = asUintN2(int64(w), 32, 16)
	case int8:
		n, err = asUintN2(int64(w), 8, 16)
	default:
		err = InvalidTypeError(v)
	}

	return uint16(n), err
}

// AsUint8 tries to convert data into a uint8
func AsUint8(v interface{}) (uint8, error) {
	var n uint64
	var err error

	switch w := v.(type) {
	case string:
		n, err = strconv.ParseUint(w, 10, 8)
	case uint8:
		return w, nil
	case uint:
		n, err = asUintN(uint64(w), IntSize, 8)
	case uint64:
		n, err = asUintN(uint64(w), 64, 8)
	case uint32:
		n, err = asUintN(uint64(w), 32, 8)
	case uint16:
		n, err = asUintN(uint64(w), 16, 8)
	case int8:
		n, err = asUintN2(int64(w), 8, 8)
	case int:
		n, err = asUintN2(int64(w), IntSize, 8)
	case int64:
		n, err = asUintN2(int64(w), 64, 8)
	case int32:
		n, err = asUintN2(int64(w), 32, 8)
	case int16:
		n, err = asUintN2(int64(w), 16, 8)
	default:
		err = InvalidTypeError(v)
	}

	return uint8(n), err
}
