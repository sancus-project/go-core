package typeconv

//go:generate ./intsize.sh

import (
	"strconv"
)

// Code generated by ./intsize.sh DO NOT EDIT

// AsIntN tries to convert data into a int of given size
func AsIntN(v interface{}, bitsize int) (int64, bool) {
	var n int64
	var ok bool

	switch w := v.(type) {
	case string:
		var err error
		n, err = strconv.ParseInt(w, 10, bitsize)
		if err == nil {
			ok = true
		}
	case int:
		n, ok = asIntN(int64(w), IntSize, bitsize)
	case int64:
		n, ok = asIntN(w, 64, bitsize)
	case int32:
		n, ok = asIntN(int64(w), 32, bitsize)
	case int16:
		n, ok = asIntN(int64(w), 16, bitsize)
	case int8:
		n, ok = asIntN(int64(w), 8, bitsize)
	case uint:
		n, ok = asIntN2(uint64(w), IntSize, 64)
	case uint64:
		n, ok = asIntN2(uint64(w), 64, 64)
	case uint32:
		n, ok = asIntN2(uint64(w), 32, 64)
	case uint16:
		n, ok = asIntN2(uint64(w), 16, 64)
	case uint8:
		n, ok = asIntN2(uint64(w), 8, 64)
	}

	return int64(n), ok
}

// AsInt64 tries to convert data into a int64
func AsInt64(v interface{}) (int64, bool) {
	var n int64
	var ok bool

	switch w := v.(type) {
	case string:
		var err error
		n, err = strconv.ParseInt(w, 10, 64)
		if err == nil {
			ok = true
		}
	case int64:
		return w, true
	case int32:
		return int64(w), true
	case int16:
		return int64(w), true
	case int8:
		return int64(w), true
	case int:
		return int64(w), true
	case uint64:
		n, ok = asIntN2(uint64(w), 64, 64)
	case uint32:
		n, ok = asIntN2(uint64(w), 32, 64)
	case uint16:
		n, ok = asIntN2(uint64(w), 16, 64)
	case uint8:
		n, ok = asIntN2(uint64(w), 8, 64)
	case uint:
		n, ok = asIntN2(uint64(w), IntSize, 64)
	}

	return int64(n), ok
}

// AsInt32 tries to convert data into a int32
func AsInt32(v interface{}) (int32, bool) {
	var n int64
	var ok bool

	switch w := v.(type) {
	case string:
		var err error
		n, err = strconv.ParseInt(w, 10, 32)
		if err == nil {
			ok = true
		}
	case int32:
		return w, true
	case int16:
		return int32(w), true
	case int8:
		return int32(w), true
	case int:
		n, ok = asIntN(int64(w), IntSize, 32)
	case int64:
		n, ok = asIntN(int64(w), 64, 32)
	case uint32:
		n, ok = asIntN2(uint64(w), 32, 32)
	case uint:
		n, ok = asIntN2(uint64(w), IntSize, 32)
	case uint64:
		n, ok = asIntN2(uint64(w), 64, 32)
	case uint16:
		n, ok = asIntN2(uint64(w), 16, 32)
	case uint8:
		n, ok = asIntN2(uint64(w), 8, 32)
	}

	return int32(n), ok
}

// AsInt16 tries to convert data into a int16
func AsInt16(v interface{}) (int16, bool) {
	var n int64
	var ok bool

	switch w := v.(type) {
	case string:
		var err error
		n, err = strconv.ParseInt(w, 10, 16)
		if err == nil {
			ok = true
		}
	case int16:
		return w, true
	case int8:
		return int16(w), true
	case int:
		n, ok = asIntN(int64(w), IntSize, 16)
	case int64:
		n, ok = asIntN(int64(w), 64, 16)
	case int32:
		n, ok = asIntN(int64(w), 32, 16)
	case uint16:
		n, ok = asIntN2(uint64(w), 16, 16)
	case uint:
		n, ok = asIntN2(uint64(w), IntSize, 16)
	case uint64:
		n, ok = asIntN2(uint64(w), 64, 16)
	case uint32:
		n, ok = asIntN2(uint64(w), 32, 16)
	case uint8:
		n, ok = asIntN2(uint64(w), 8, 16)
	}

	return int16(n), ok
}

// AsInt8 tries to convert data into a int8
func AsInt8(v interface{}) (int8, bool) {
	var n int64
	var ok bool

	switch w := v.(type) {
	case string:
		var err error
		n, err = strconv.ParseInt(w, 10, 8)
		if err == nil {
			ok = true
		}
	case int8:
		return w, true
	case int:
		n, ok = asIntN(int64(w), IntSize, 8)
	case int64:
		n, ok = asIntN(int64(w), 64, 8)
	case int32:
		n, ok = asIntN(int64(w), 32, 8)
	case int16:
		n, ok = asIntN(int64(w), 16, 8)
	case uint8:
		n, ok = asIntN2(uint64(w), 8, 8)
	case uint:
		n, ok = asIntN2(uint64(w), IntSize, 8)
	case uint64:
		n, ok = asIntN2(uint64(w), 64, 8)
	case uint32:
		n, ok = asIntN2(uint64(w), 32, 8)
	case uint16:
		n, ok = asIntN2(uint64(w), 16, 8)
	}

	return int8(n), ok
}

// AsUintN tries to convert data into a uint of given size
func AsUintN(v interface{}, bitsize int) (uint64, bool) {
	var n uint64
	var ok bool

	switch w := v.(type) {
	case string:
		var err error
		n, err = strconv.ParseUint(w, 10, bitsize)
		if err == nil {
			ok = true
		}
	case uint:
		n, ok = asUintN(uint64(w), IntSize, bitsize)
	case uint64:
		n, ok = asUintN(w, 64, bitsize)
	case uint32:
		n, ok = asUintN(uint64(w), 32, bitsize)
	case uint16:
		n, ok = asUintN(uint64(w), 16, bitsize)
	case uint8:
		n, ok = asUintN(uint64(w), 8, bitsize)
	case int:
		n, ok = asUintN2(int64(w), IntSize, 64)
	case int64:
		n, ok = asUintN2(int64(w), 64, 64)
	case int32:
		n, ok = asUintN2(int64(w), 32, 64)
	case int16:
		n, ok = asUintN2(int64(w), 16, 64)
	case int8:
		n, ok = asUintN2(int64(w), 8, 64)
	}

	return uint64(n), ok
}

// AsUint64 tries to convert data into a uint64
func AsUint64(v interface{}) (uint64, bool) {
	var n uint64
	var ok bool

	switch w := v.(type) {
	case string:
		var err error
		n, err = strconv.ParseUint(w, 10, 64)
		if err == nil {
			ok = true
		}
	case uint64:
		return w, true
	case uint32:
		return uint64(w), true
	case uint16:
		return uint64(w), true
	case uint8:
		return uint64(w), true
	case uint:
		return uint64(w), true
	case int64:
		n, ok = asUintN2(int64(w), 64, 64)
	case int32:
		n, ok = asUintN2(int64(w), 32, 64)
	case int16:
		n, ok = asUintN2(int64(w), 16, 64)
	case int8:
		n, ok = asUintN2(int64(w), 8, 64)
	case int:
		n, ok = asUintN2(int64(w), IntSize, 64)
	}

	return uint64(n), ok
}

// AsUint32 tries to convert data into a uint32
func AsUint32(v interface{}) (uint32, bool) {
	var n uint64
	var ok bool

	switch w := v.(type) {
	case string:
		var err error
		n, err = strconv.ParseUint(w, 10, 32)
		if err == nil {
			ok = true
		}
	case uint32:
		return w, true
	case uint16:
		return uint32(w), true
	case uint8:
		return uint32(w), true
	case uint:
		n, ok = asUintN(uint64(w), IntSize, 32)
	case uint64:
		n, ok = asUintN(uint64(w), 64, 32)
	case int32:
		n, ok = asUintN2(int64(w), 32, 32)
	case int:
		n, ok = asUintN2(int64(w), IntSize, 32)
	case int64:
		n, ok = asUintN2(int64(w), 64, 32)
	case int16:
		n, ok = asUintN2(int64(w), 16, 32)
	case int8:
		n, ok = asUintN2(int64(w), 8, 32)
	}

	return uint32(n), ok
}

// AsUint16 tries to convert data into a uint16
func AsUint16(v interface{}) (uint16, bool) {
	var n uint64
	var ok bool

	switch w := v.(type) {
	case string:
		var err error
		n, err = strconv.ParseUint(w, 10, 16)
		if err == nil {
			ok = true
		}
	case uint16:
		return w, true
	case uint8:
		return uint16(w), true
	case uint:
		n, ok = asUintN(uint64(w), IntSize, 16)
	case uint64:
		n, ok = asUintN(uint64(w), 64, 16)
	case uint32:
		n, ok = asUintN(uint64(w), 32, 16)
	case int16:
		n, ok = asUintN2(int64(w), 16, 16)
	case int:
		n, ok = asUintN2(int64(w), IntSize, 16)
	case int64:
		n, ok = asUintN2(int64(w), 64, 16)
	case int32:
		n, ok = asUintN2(int64(w), 32, 16)
	case int8:
		n, ok = asUintN2(int64(w), 8, 16)
	}

	return uint16(n), ok
}

// AsUint8 tries to convert data into a uint8
func AsUint8(v interface{}) (uint8, bool) {
	var n uint64
	var ok bool

	switch w := v.(type) {
	case string:
		var err error
		n, err = strconv.ParseUint(w, 10, 8)
		if err == nil {
			ok = true
		}
	case uint8:
		return w, true
	case uint:
		n, ok = asUintN(uint64(w), IntSize, 8)
	case uint64:
		n, ok = asUintN(uint64(w), 64, 8)
	case uint32:
		n, ok = asUintN(uint64(w), 32, 8)
	case uint16:
		n, ok = asUintN(uint64(w), 16, 8)
	case int8:
		n, ok = asUintN2(int64(w), 8, 8)
	case int:
		n, ok = asUintN2(int64(w), IntSize, 8)
	case int64:
		n, ok = asUintN2(int64(w), 64, 8)
	case int32:
		n, ok = asUintN2(int64(w), 32, 8)
	case int16:
		n, ok = asUintN2(int64(w), 16, 8)
	}

	return uint8(n), ok
}
