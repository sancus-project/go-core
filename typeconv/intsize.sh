#!/bin/sh

set -eu

F="${0%.sh}.go"
trap "rm -f '$F~'" EXIT
exec > "$F~"

cat <<EOT
package typeconv

//go:generate $0

import (
	"strconv"
)

// Code generated by $0 DO NOT EDIT
EOT

generateN() {
	local N="$1" S="64" a=
	local n="${N}$S"
	local t="$(echo "$n" | tr A-Z a-z)"
	local t0="$(echo "$N" | tr A-Z a-z)"
	local sizes="64 32 16 8"
	local x= w=

	if [ "$t0" = int ]; then
		a=an
	else
		a=a
	fi
	cat <<EOT

// As${N}N tries to convert data into $a $t0 of given size
func As${N}N(v interface{}, bitsize int) ($t, error) {
	var n $t
	var err error

	switch w := v.(type) {
	case string:
		n, err = strconv.Parse$N(w, 10, bitsize)
	case $t0:
		n, err = as${N}N($t(w), IntSize, bitsize)
EOT

for x in $sizes; do
	s=$x
	if [ "$x" = "$S" ]; then
		w=w
	else
		w="$t(w)"
	fi

	cat <<EOT
	case $t0$x:
		n, err = as${N}N($w, $s, bitsize)
EOT
done

# inverted sign
case "$t0" in
int)    t1="uint" p=asIntN2 ;;
uint)   t1="int" p=asUintN2;;
*)      t1= ;;
esac

if [ -n "$t1" ]; then
	for x in + $sizes; do
		if [ "$x" = + ]; then
			s=IntSize
			x=
		else
			s=$x
		fi
	cat <<EOT
	case ${t1}$x:
		n, err = $p(${t1}64(w), $s, $S)
EOT
	done
fi

cat <<EOT
	default:
		err = InvalidTypeError(v)
	}

	return $t(n), err
}
EOT
}

generate() {
	local N="$1" S="$2" a=
	local n="$N$S"
	local t="$(echo "$n" | tr A-Z a-z)"
	local t0="$(echo "$N" | tr A-Z a-z)"
	local lower= greater=
	local x=

	if [ "$t0" = int ]; then
		a=an
	else
		a=a
	fi

	for x in 64 32 16 8; do
		if [ $x -gt $S ]; then
			greater="${greater:+$greater }$x"
		elif [ $x -lt $S ]; then
			lower="${lower:+$lower }$x"
		fi
	done

	if [ $S -eq 64 ]; then
		lower="${lower:+$lower }+"
	else
		greater="+${greater:+ $greater}"
	fi

	cat <<EOT

// As$n tries to convert data into $a $t
func As$n(v interface{}) ($t, error) {
	var n ${t0}64
	var err error

	switch w := v.(type) {
	case string:
		n, err = strconv.Parse$N(w, 10, $S)
	case $t:
		return w, nil
EOT

# smaller types are always good
	for x in $lower; do
		if [ "$x" = '+' ]; then
			x=
		fi
cat <<EOT
	case $t0$x:
		return $t(w), nil
EOT
	done

# larger types need to be checked for overflows
	for x in $greater; do

	if [ "$x" = '+' ]; then
		s=IntSize
		x=
	else
		s=$x
	fi

cat <<EOT
	case $t0$x:
		n, err = as${N}N(${t0}64(w), $s, $S)
EOT
	done

# inverted sign
case "$t0" in
int)    t1="uint" p=asIntN2 ;;
uint)   t1="int" p=asUintN2;;
*)      t1= ;;
esac

if [ -n "$t1" ]; then
	for x in $S $greater $lower; do
		if [ "$x" = '+' ]; then
			s=IntSize
			x=
		else
			s=$x
		fi
		cat <<EOT
	case $t1$x:
		n, err = $p(${t1}64(w), $s, $S)
EOT
	done
fi

cat <<EOT
	default:
		err = InvalidTypeError(v)
	}

	return $t(n), err
}
EOT
}

for x in Int Uint; do
	generateN $x

	for k in 64 32 16 8; do
		generate $x $k
	done
done

if ! cmp -s "$F" "$F~" 2> /dev/null; then
	mv "$F~" "$F"
fi
