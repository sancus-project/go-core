#!/bin/sh

set -eu

F="${0%.sh}.go"
trap "rm -f '$F~'" EXIT
exec > "$F~"

cat <<EOT
package errors

//go:generate $0

import (
	"fmt"
)

// Code generated by $0 DO NOT EDIT
EOT

generate() {
	local N="$1$2"
	local S="$1 $2"

cat <<EOT

// Error representing a $S
type ${N}Error struct {
	s   string
	err error
}

func (e ${N}Error) Unwrap() error {
	return e.err
}

func (e ${N}Error) Error() string {
	s := "$S"

	if len(e.s) > 0 {
		s = fmt.Sprintf("%s: %s", s, e.s)
	}

	if e.err != nil {
		s = fmt.Sprintf("%s: %s", s, e.err.Error())
	}

	return s
}

// Creates new ${N}Error formatting arguments
func Err$N(str string, args ...interface{}) *${N}Error {
	if len(args) > 0 {
		str = fmt.Sprintf(str, args...)
	}

	if len(str) > 0 {
		return &${N}Error{str, nil}
	}

	return nil
}

func As${N}Error(err error, str string, args ...interface{}) *${N}Error {
	if err != nil {
		e := Err$N(str, args...)
		if e != nil {
			e.err = err
		} else {
			e = &${N}Error{"", err}
		}
		return e
	}
	return nil
}

// Adds $N to ErrorStack
func (s *ErrorStack) $N(str string, args ...interface{}) {
	if err := Err$N(str, args...); err != nil {
		s.errors = append(s.errors, err)
	}
}

// Adds wrapped error as $N to ErrorStack
func (s *ErrorStack) Append${N}Error(err error, str string, args ...interface{}) {
	if e := As${N}Error(err, str, args...); e != nil {
		s.errors = append(s.errors, e)
	}
}
EOT
}

# Missing
for x in Field Argument; do
	generate Missing $x
done

# Invalid
for x in Value Argument; do
	generate Invalid $x
done

generate Not Implemented

if ! diff -u "$F" "$F~" >&2; then
	mv "$F~" "$F"
fi
