#!/bin/sh

set -eu

F="${0%.sh}.go"
trap "rm -f '$F~'" EXIT
exec > "$F~"

cat <<EOT
package errors

//go:generate $0

import (
	"fmt"
	"strings"
)

// Code generated by $0 DO NOT EDIT

// Convenience Error type
type ArgumentError struct {
	prefix string
	msg    string
	err    error
}

func (e ArgumentError) Unwrap() error {
	return e.err
}

func (e ArgumentError) Error() string {
	var s = []string{e.prefix}

	if len(e.msg) > 0 {
		s = append(s, e.msg)
	}

	if e.err != nil {
		s = append(s, e.err.Error())
	}

	return strings.Join(s, ": ")
}
EOT

generate() {
	local N="$1$2"
	local S="$1 $2"

cat <<EOT

// Creates new ${N}Error formatting arguments
func Err$N(str string, args ...interface{}) *ArgumentError {
	if len(args) > 0 {
		str = fmt.Sprintf(str, args...)
	}

	if len(str) > 0 {
		return &ArgumentError{"$S", str, nil}
	}

	return nil
}

func As${N}Error(err error, str string, args ...interface{}) *ArgumentError {
	if err != nil {
		if len(args) > 0 {
			str = fmt.Sprintf(str, args...)
		}

		return &ArgumentError{"$S", str, err}
	}

	return nil
}

// Adds $N to ErrorStack
func (s *ErrorStack) $N(str string, args ...interface{}) {
	if err := Err$N(str, args...); err != nil {
		s.errors = append(s.errors, err)
	}
}

// Adds wrapped error as $N to ErrorStack
func (s *ErrorStack) Append${N}Error(err error, str string, args ...interface{}) {
	if e := As${N}Error(err, str, args...); e != nil {
		s.errors = append(s.errors, e)
	}
}
EOT
}

# Missing
for x in Field Argument; do
	generate Missing $x
done

# Invalid
for x in Value Argument; do
	generate Invalid $x
done

generate Not Implemented

if ! diff -u "$F" "$F~" >&2; then
	mv "$F~" "$F"
fi
